
# Σχετικά με τη Sass

Η [Sass](http://sass-lang.com) αυτοπροσδιορίζεται στο [documentation](http://sass-lang.com/documentation/file.SASS_REFERENCE.html) ως εξής:

> Η Sass είναι μία επέκταση της CSS η οποία προσθέτει ισχύ και κομψότητα στη βασική γλώσσα.

Ο απώτερος στόχος της είναι να διορθώσει τα ελλατώματα της CSS. Όπως όλοι γνωρίζουμε, Η CSS δεν είναι και η καλύτερη γλώσσα στον κόσμο <sup>[εκκρεμεί παραπομπή]</sup>. Αν και είναι πολύ απλή στην εκμάθηση, μπορεί να γίνει ακατάστατη πολύ γρήγορα, ειδικά σε μεγάλα projects.

Σ'αυτό το σημείο έρχεται η Sass, ως μία μετα-γλώσσα, για να βελτιώσει τη σύνταξη της CSS ώστε να της παρέχει επιπλέον δυνατότητες και βολικά εργαλεία. Παράλληλα, η Sass επιδιώκει να παραμείνει συντηρητική σε σχέση με τη γλώσσα CSS.

Το ζητούμενο δεν είναι να μετατρέψει τη CSS σε μία γλώσσα προγραμματισμού πλήρη δυνατοτήτων· η Sass επιδιώκει να βοηθήσει μόνο εκεί που η CSS αποτυγχάνει. Εξαιτίας αυτού, το να ξεκινήσεις να μαθαίνεις Sass δεν είναι πιο δύσκολο από το να μαθαίνεις CSS: απλά προσθέτει μερικές επιπλέον δυνατότητες πάνω στις ήδη υπάρχουσες.

Εντούτοις, υπάρχουν πολλοί τρόποι να χρησιμοποιήσουμε αυτές τις δυνατότητες. Κάποιοι καλοί, κάποιοι κακοί και κάποιοι ασυνήθιστοι. Αυτά τα guidelines έχουν σκοπό να σου δώσουν μία συνεκτική και τεκμηριωμένη προσέγγιση για τη συγγραφή κώδικα σε Sass.

### Περαιτέρω ανάγνωση

* [SitePoint Sass Reference](http://sitepoint.com/sass-reference/)

## Ruby Sass ή LibSass

[Το πρώτο commit της Sass](https://github.com/hcatlin/sass/commit/fa5048ba405619273e474a50400c7243fbff54fe) ανάγεται στα τέλη του 2006, πάνω από 8 χρόνια πριν. Περιττό να πούμε ότι έχει διανύσει πολύ δρόμο από τότε. Αρχικά αναπτύχθηκε σε Ruby, και διάφορα ports ξεφύτρωσαν από δω κι από κει. Το πιο δημοφιλές, το [LibSass](https://github.com/sass/libsass) (γραμμένο σε C/C++), είναι πλέον κοντά στο να είναι πλήρως συμβατό με την πρωτότυπη έκδοση σε Ruby.

Το 2014, [οι ομάδες του Ruby Sass και του LibSass αποφάσισαν να περιμένουν και τις δύο εκδόσεις να συγχρονιστούν πριν προχωρήσουν παραπέρα](https://github.com/sass/libsass/wiki/The-LibSass-Compatibility-Plan). Από τότε, το LibSass δημοσιεύει τακτικά νέες εκδόσεις μέχρι να φτάσει τον μεγαλύτερο αδερφό του σε δυνατότητες. Οι τελευταίες ασυνέπειες που έχουν απομείνει έχουν συγκεντρωθεί και τις παραθέτω στο [Sass-Compatibility](http://sass-compatibility.github.io) project. Αν έχεις υπόψη σου κάποια ασυνέπεια μεταξύ των δύο εκδόσεων που δεν αναφέρεται, μπορείς να ανοίξεις ένα issue αν έχεις την καλοσύνη.

Επιστρέφουμε στην επιλογή του compiler. Βασικά εξαρτάται από το project σου. Αν είναι ένα project σε Ruby on Rails, καλύτερα να χρησιμοποιήσεις το Ruby Sass, που ταιριάζει απόλυτα στην περίπτωση. Επίσης, να ξέρεις ότι το Ruby Sass θα είναι πάντα το σημείο αναφοράς όσον αφορά την υλοποίηση της Sass και πάντα θα προηγείται του LibSass σε δυνατότητες.

Όταν θέλεις να εντάξεις τη Sass στη ροή εργασίας σου σε κάποιο project που δεν είναι σε Ruby, το LibSass είναι πιθανώς καλύτερη ιδέα επειδή είναι εξειδικευμένο γι' αυτή την περίπτωση. Οπότε αν θες να χρησιμοποιήσεις ας πούμε NodeJS, το [node-sass](https://github.com/sass/node-sass) είναι το πιο επιθυμητό.

### Περαιτέρω ανάγνωση

* [Getting to know LibSass](http://webdesign.tutsplus.com/articles/getting-to-know-libsass--cms-23114)
* [Switching from Ruby Sass to LibSass](http://www.sitepoint.com/switching-ruby-sass-libsass/)

## Sass ή SCSS

Επικρατεί μεγάλη σύγχυση σχετικά με τη σημειολογία της ονομασίας *Sass*, για έναν καλό λόγο: ως Sass εννοούμε και τον preprocessor και τη σύνταξη της γλώσσας. Λίγο άβολο, έτσι δεν είναι;

Βλέπεις, η Sass αρχικά περιέγραφε μία σύνταξη στην οποία το βασικό χαρακτηριστικό ήταν η ευαισθησία στο indentation. Σύντομα οι συντηρητές της Sass αποφάσισαν να γεφυρώσουν το χάσμα μεταξύ Sass και CSS παρέχοντας μια σύνταξη φιλική ως προς τη CSS με το όνομα *SCSS*, που σημαίνει *Sassy CSS* (ζωηρή CSS). Το σύνθημα είναι το εξής: αν είναι έγκυρη CSS, τότε είναι έγκυρη SCSS.

Από τότε, η Sass (ο preprocessor) παρέχει δύο διαφορετικές συντάξεις: τη Sass (χωρίς κεφαλαία [παρακαλώ](http://sassnotsass.com)), επίσης γνωστή ως *την indented σύνταξη*, και την SCSS. Το ποιά σύνταξη θα χρησιμοποιήσεις είναι στο χέρι σου μιας και οι δύο έχουν ακριβώς τις ίδιες δυνατότητες. Σ' αυτό το σημείο είναι θέμα προτίμησης.

Η whitespace-sensitive σύνταξη της Sass βασίζεται στο indentation για να απαλλαγεί από τα άγκιστρα (braces), τα ερωτηματικά (semi-colons) και άλλα σημεία στίξης, πράγμα που οδηγεί σε μια πιο λιτή και πιο σύντομη σύνταξη. Παράλληλα, η SCSS είναι πιο εύκολη στην εκμάθηση μιας και πρόκειται για μερικά μικρά επιπλέον κομμάτια πάνω στη CSS.

Εγώ προσωπικά προτιμώ την SCSS από τη Sass γιατί είναι πιο κοντά στη CSS και πιο φιλική για τους περισσότερους developers. Γι' αυτό το λόγο, θα χρησιμοποιώ SCSS αντί για Sass σ' αυτά τα guidelines.

### Περαιτέρω ανάγνωση

* [What's the difference between Sass and SCSS](http://www.sitepoint.com/whats-difference-sass-scss/)

## Λοιποί preprocessors

Η Sass είναι ένας preprocessor μεταξύ άλλων. Ο πιο σοβαρός ανταγωνιστής της είναι η [Less](http://lesscss.org/), ένας preprocessor που βασίζεται σε NodeJS, ο οποίος έχει γίνει αρκετά δημοφιλής χάρη στο γνωστό CSS framework [Bootstrap](http://getbootstrap.com/) που το χρησιμοποιεί (μέχρι την 4η έκδοση). Επίσης υπάρχει και το [Stylus](http://learnboost.github.io/stylus/), ένα πολύ επιτρέπων και ευέλικτο preprocessor όμως ελαφρώς δυσκολότερο στην χρήση και με μικρότερη κοινότητα.

Το *γιατί να επιλέξω Sass αντί κάποιον άλλον preprocessor* είναι μία βάσιμη απορία ακόμα και σήμερα. Μέχρι πρόσφατα συνιστούσαμε Sass για projects σε Ruby γιατί ο preprocessor ήταν φτιαγμένος σε Ruby και κούμπωνε καλά με το Ruby on Rails. Τώρα που το LibSass έχει συμβαδίσει (σχεδόν) με το πρωτότυπο Sass, πλέον δεν τίθεται τέτοιο θέμα.

Αυτό που μ' αρέσει στη Sass είναι η συντηρητική της προσέγγιση απέναντι στη CSS. Ο σχεδιασμός της Sass βασίζεται σε ισχυρές αρχές: οι περισσότερες σχεδιαστικές προσεγγίσεις προέρχονται φυσικά από τις πεποιθήσεις των ιδρυτών της πως α) το να προσθέτεις επιπλέον δυνατότητες έχει μία επιβάρυνση σε πολυπλοκότητα η οποία πρέπει να δικαιολογείται από τη χρησιμότητα και β) πρέπει να είναι απλό να κατανοήσεις τι κάνει ένα συγκεκριμένο κομμάτι από styles μελετώντας το απομονωμένα. Επίσης, η Sass δίνει πολύ αυστηρότερη έμφαση στη λεπτομέρεια σε σχέση με άλλους preprocessors. Απ' όσο μπορώ να πω, οι βασικοί σχεδιαστές νοιάζονται πολύ για την υποστήριξη της κάθε παραμικρής συμβατότητας με τη CSS και φροντίζουν η γενική συμπεριφορά της γλώσσας να είναι συνεπής.

Με άλλα λόγια, η Sass δεν είναι ένα λογισμικό στοχευμένο στο να λύνει πρακτικά ζητήματα· στο να παρέχει χρήσιμες δυνατότητες εκεί που η CSS υπολείπεται.

Πέρα από τους preprocessors, πρέπει να επισημάνουμε και εργαλεία post-processing, τα οποία έχουν αποκτήσει σημαντική δημοσιότητα τους τελευταίους μήνες, κυρίως χάρη στο [PostCSS](https://github.com/postcss/postcss) και στο [cssnext](https://cssnext.github.io/). Συχνά αναφέρονται ως «postprocessors» επειδή κάνουν transpile επερχόμενες συντακτικές αλλαγές σε τωρινή CSS. Πέρα απ' αυτό, είναι πάνω κάτω ισοδύναμοι με τους preprocessors με την εξαίρεση ότι δεν παρέχουν τίποτα περισσότερο από επερχόμενες συντακτικές δυνατότητες της CSS.

Δες τους postprocessors σαν ένα polyfill για δυνατότητες της CSS που δεν υποστηρίζονται ακόμα. Για παράδειγμα, μπορείς να γράψεις μεταβλητές όπως περιγράφονται στις [προδιαγραφές της CSS](http://dev.w3.org/csswg/css-variables/), και ύστερα να κάνεις compile τα stylesheets με έναν postprocessor, με αποτέλεσμα όπου εμφανίζεται η μεταβλητή να έχει αντικατασταθεί από την τιμή της, όπως θα έκανε και η Sass.

Το σκεπτικό πίσω από τους postprocessors είναι ότι μόλις οι φυλλομετρητές υποστηρίξουν νέες δυνατότητες (π.χ. μεταβλητές CSS), ο postprocessor δεν τις κάνει compile πια και αφήνει τους φυλλομετρητές να τις διαχειριστούν.

Παρότι η ιδέα του να παρέχουμε υποστήριξη για μελλοντικές συντάξεις ακούγεται αξιότιμη ιδέα, μπορώ να πως πως προτιμώ να χρησιμοποιώ Sass για τις περισσότερες εργασίες. Πάραυτα, υπάρχουν μερικές περιπτώσεις που πιστεύω ότι οι postprocessors είναι καταλληλότεροι από τη Sass και τα συναφή - το CSS prefixing για παράδειγμα - αλλά θα επανέλθουμε πάνω σ'αυτό.
